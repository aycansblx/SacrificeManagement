<!DOCTYPE html>
<html>
<head>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
    <title>(S)acrifice (M)anagement</title>
</head>
<body>
    <script>

        // each side has 5 crowd member
        const ROW_COUNT = 5;
        // horizontal positions of crowd member inventories (left and right respectively)
        const FIRST_COL_X = 140;
        const SECND_COL_X = 660;
        // vertical offset of the first crowd member from the top of the screen and row heights
        const ROW_OFFSET = 100;
        const OBJ_HEIGHT = 80;
        // hud color palette
        const ALT_CL_NTR = 0xe6e6e6;
        const ALT_CL_DC1 = 0xff0000;
        const ALT_CL_DC2 = 0x990000;
        const ALT_CL_IN1 = 0x00ff00;
        const ALT_CL_IN2 = 0x009900;
        // the rest - animation durations, alpha values etc.
        const HIGHLIGHTED_ALPHA = 0.7;
        const HIGHLIGHT_DURATION = 330;
        const RISE_DURATION = 500;
        const ANIMATION_DURATION = 1000;
        const FEEDBACK_DURATION = 2500;
        const END_LEVEL_DURATION = 2000;
        // audio and shit
        const MENU_VOLUME = 0.4;
        const GAME_VOLUME = 0.2;
        const TICK_VOLUME = 0.1;

        var elementCounts = [2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9];
        var levelDurations = [20, 20, 25, 25, 30, 30, 30, 40, 40, 40, 45, 45, 45, 45];
        var relationCounts = [0, 1, 2, 4, 4, 7, 7, 7, 6, 7, 8, 7, 7, 8];

        var crowdData = [
            {   type: "Human",
                species: [
                    "tim", 
                    "tom",
                    "mark", 
                    "eric",
                    "brian", 
                    "roger",
                    "donald",
                ],
                averageSacredness: [4, 5, 4, 3, 4, 5, 5,],
            },
            {   type: "Animal",
                species: [
                    "cow", 
                    "dog", 
                    "cat", 
                    "lamb", 
                    "mouse", 
                    "flies", 
                    "caterpillar",
                ],
                averageSacredness: [3, 2, 1, 3, 0, 0, 0],
            },
            {   type: "Plant",
                species: [
                    "wheat",
                    "apple",
                    "curry",
                    "flower",
                    "potato",
                    "banana",
                    "tomato",
                ],
                averageSacredness: [1, 2, 1, 1, 3, 2, 1],
            },
            {   type: "Object",
                species: [
                    "book",
                    "rock",
                    "gold",
                    "wine",
                    "crown",
                    "goblet",
                    "candle",
                ],
                averageSacredness: [1, 0, 2, 1, 2, 1, 0],
            }
        ];

        var HUDStyle = {
            fontSize: "18px",
            fontFamily: "Arial",
            color: "#ffffff",
            align: "center",
            shadow: {
                color: '#000000',
                fill: true,
                offsetX: 2,
                offsetY: 2,
                blur: 8
            },
        }

        var infoBoxStyle = {
            fontSize: "16px",
            fontFamily: "Arial",
            color: "#ffffff",
            backgroundColor: '#a25a53',
            shadow: {
                color: '#000000',
                fill: true,
                offsetX: 2,
                offsetY: 2,
                blur: 8
            },
            padding: {
                x: 8,
                y: 8,
            },
        };

        var positiveFeedback = {
            fontSize: "32px",
            fontFamily: "Arial",
            color: "#00ff00",
            align: "center",
            shadow: {
                color: '#e6e6e6',
                fill: true,
                offsetX: 2,
                offsetY: 2,
                blur: 8
            },
            padding: {
                x: 8,
                y: 8,
            },
            stroke: {
                color: "#000000",
                size: 2,
            },
        };

        var negativeFeedback = {
            fontSize: "32px",
            fontFamily: "Arial",
            color: "#ff0000",
            align: "center",
            shadow: {
                color: '#e6e6e6',
                fill: true,
                offsetX: 2,
                offsetY: 2,
                blur: 8
            },
            padding: {
                x: 8,
                y: 8,
            },
            stroke: {
                color: "#000000",
                size: 2,
            },
        };

        var SMBM = new Phaser.Class({
            Extends: Phaser.Scene,
            
            altar: [],
            hovered: undefined,
            crowd: [],
            selected: undefined,

            informed: undefined,
            infoCard: undefined,

            level: 0,
            score: 0,
            limit: 5,
            timer: 0,

            scoreHUD: undefined,
            timerHUD: undefined,
            levelHUD: undefined,
            gameOverHUD: undefined,
            lastScoreHUD: undefined,

            menuTitle: undefined,
            menuMug: undefined,
            menuTutorial: undefined,

            altarStar: undefined,

            theme: undefined,
            tick: undefined,
            placefx: undefined,
            resetfx: undefined,

            lock: false,

            initialize: function SBMB() {
                Phaser.Scene.call(this, { key: "SBMB" });
            },

            preload: function() {
                this.load.image("temp", "temp.png");
                this.load.image("background", "background.png");
                this.load.image("altar", "altar.png");

                this.load.image("book", "./objects/book.png");
                this.load.image("rock", "./objects/rock.png");
                this.load.image("gold", "./objects/gold.png");
                this.load.image("wine", "./objects/wine.png");
                this.load.image("crown", "./objects/crown.png");
                this.load.image("goblet", "./objects/goblet.png");
                this.load.image("candle", "./objects/candle.png");

                this.load.image("wheat", "./plants/wheat.png");
                this.load.image("apple", "./plants/apple.png");
                this.load.image("curry", "./plants/curry.png");
                this.load.image("flower", "./plants/flower.png");
                this.load.image("potato", "./plants/potato.png");
                this.load.image("banana", "./plants/banana.png");
                this.load.image("tomato", "./plants/tomato.png");

                this.load.image("cow", "./animals/cow.png");
                this.load.image("dog", "./animals/dog.png");
                this.load.image("cat", "./animals/cat.png");
                this.load.image("lamb", "./animals/lamb.png");
                this.load.image("mouse", "./animals/mouse.png");
                this.load.image("flies", "./animals/flies.png");
                this.load.image("caterpillar", "./animals/caterpillar.png");

                this.load.image("tim", "./human/tim.png");
                this.load.image("tom", "./human/tom.png");
                this.load.image("eric", "./human/eric.png");
                this.load.image("mark", "./human/mark.png");
                this.load.image("brian", "./human/brian.png");
                this.load.image("roger", "./human/roger.png");
                this.load.image("donald", "./human/donald.png");

                this.load.image("title", "./menu/title.png");
                this.load.image("mug", "./menu/mug.png");
                this.load.image("tutorial", "./menu/tutorial.png");

                this.load.audio("theme", [
                    './audio/theme.ogg',
                    './audio/theme.mp3'
                ]);
                this.load.audio("tick", [
                    './audio/tick.ogg',
                    './audio/tick.mp3'
                ]);
                this.load.audio("place", [
                    './audio/place.ogg',
                    './audio/place.mp3'
                ]);
                this.load.audio("reset", [
                    './audio/reset.ogg',
                    './audio/reset.mp3'
                ]);
            },
            
            create: function() {
                this.add.image(400, 300, "background");

                this.theme = this.sound.add("theme", {
                    mute: false,
                    volume: MENU_VOLUME,
                    rate: 1,
                    detune: 0,
                    seek: 0,
                    loop: true,
                    delay: 0
                });
                this.theme.play();

                this.tick = this.sound.add("tick", {
                    mute: false,
                    volume: TICK_VOLUME,
                    rate: 1,
                    detune: 0,
                    seek: 0,
                    loop: false,
                    delay: 0,
                });

                this.placefx = this.sound.add("place", {
                    mute: false,
                    volume: TICK_VOLUME,
                    rate: 1,
                    detune: 0,
                    seek: 0,
                    loop: false,
                    delay: 0,
                });

                this.resetfx = this.sound.add("reset", {
                    mute: false,
                    volume: TICK_VOLUME,
                    rate: 1,
                    detune: 0,
                    seek: 0,
                    loop: false,
                    delay: 0,
                });

                this.infoCard = this.add.text(0, 0, "", infoBoxStyle);
                this.infoCard.depth = 5;
                this.levelHUD = this.add.text(390, 245, "", HUDStyle).setOrigin(0.5, 0.5);
                this.levelHUD.depth = 5;
                this.scoreHUD = this.add.text(390, 280, "", HUDStyle).setOrigin(0.5,0.5);
                this.scoreHUD.depth = 5;
                this.timerHUD = this.add.text(390, 330, "", HUDStyle).setOrigin(0.5,0.5);
                this.timerHUD.depth = 5;

                this.createMenu();

                this.input.on("pointerdown", function (pointer) {
                    if (this.lock)
                        return;
                    if (this.level == 0) {
                        if (pointer.x > 297 && pointer.x < 389 && pointer.y > 306 && pointer.y < 417)
                            this.startGame();
                    } else 
                        this.selectCrowdMember(pointer.x, pointer.y);
                }, this);

                this.input.on("pointermove", function (pointer) {
                    if (this.lock)
                        return;
                    if (this.level == 0)
                        return;
                    // if there's a selected crowd member then move it and check the altar
                    if (this.selected != null) {
                        this.moveSelectedCrowdMember(pointer.x - pointer.downX, pointer.y - pointer.downY);
                        this.checkAltar(pointer.x, pointer.y);
                    } 
                    // otherwise, just check crowd members and fill the corresponding info box
                    else
                        this.checkCrowd(pointer.x, pointer.y);
                }, this);

                this.input.on("pointerup", function () {        
                    if (this.lock)
                        return;
                    if(this.level == 0)
                        return;
                    // if there is a selected crowd member and a pointed altar part
                    if (this.selected && this.hovered)
                        this.process();
                    // if there is just a selected crowd member
                    else if (this.selected)
                        this.reset();
                }, this);
            },

            createMenu: function() {
                this.menuTitle = this.add.image(400, 300, "title");
                this.menuMug = this.add.image(400, 300, "mug");
                this.menuTutorial = this.add.image(400, 300, "tutorial");
            },

            startGame: function() {
                this.level++;
                this.tweens.add({
                    targets: this.menuTitle,
                    y: -400,
                    duration: ANIMATION_DURATION,
                    onComplete: globalGameStarter,
                    onCompleteParams: [this],
                    ease: 'Back.easeInOut',
                });
                if (this.gameOverHUD != undefined && this.lastScoreHUD != undefined) {
                    this.tweens.add({
                        targets: this.gameOverHUD,
                        y: -400,
                        duration: ANIMATION_DURATION,
                        onComplete: globalDestroyer,
                        onCompleteParams: [this.gameOverHUD],
                        ease: 'Back.easeInOut',
                    });
                    this.tweens.add({
                        targets: this.lastScoreHUD,
                        y: -400,
                        duration: ANIMATION_DURATION,
                        onComplete: globalDestroyer,
                        onCompleteParams: [this.lastScoreHUD],
                        ease: 'Back.easeInOut',
                    });
                }
                this.gameOverHUD = undefined;
                this.lastScoreHUD = undefined;
                this.tweens.add({
                    targets: this.menuMug,
                    y: 1200,
                    duration: ANIMATION_DURATION,
                    ease: 'Back.easeInOut',
                    onComplete: globalDestroyer,
                    onCompleteParams: [this.menuMug],
                });
                this.tweens.add({
                    targets: this.menuTutorial,
                    x: 900,
                    duration: ANIMATION_DURATION,
                    ease: 'Back.easeInOut',
                    onComplete: globalDestroyer,
                    onCompleteParams: [this.menuTutorial],
                });
                this.theme.volume = GAME_VOLUME;
            },

            createGame: function() {
                this.createAltar();

                this.altarStar = this.add.image(400, 300, "altar").setAlpha(0);

                this.tweens.add({
                    targets: this.altarStar,
                    alpha: 1,
                    duration: ANIMATION_DURATION,
                    ease: 'Back.easeInOut',
                });

                this.time.delayedCall(ANIMATION_DURATION, globalLevelStarter, [this]);
            },

            createAltar: function() {
                this.altar.push({
                    shape: new Phaser.Geom.Polygon([ 211, 348, 327, 261, 292, 120]),
                    image: this.add.polygon(55,120, [211, 348, 327, 261, 292, 120], ALT_CL_NTR).setAlpha(0),
                    primaryNeighbors: [1, 3],
                    secondaryNeighbors: [],
                });
                this.altar.push({
                    shape: new Phaser.Geom.Polygon([327, 261, 292, 120, 392, 209]),
                    image: this.add.polygon(50,70, [327, 261, 292, 120, 392, 209], ALT_CL_NTR).setAlpha(0),
                    primaryNeighbors: [0, 2],
                    secondaryNeighbors: [3, 4],
                });
                this.altar.push({
                    shape: new Phaser.Geom.Polygon([ 292, 120, 392, 209, 491, 128]),
                    image: this.add.polygon(100,45, [292, 120, 392, 209, 491, 128], ALT_CL_NTR).setAlpha(0),
                    primaryNeighbors: [1, 4],
                    secondaryNeighbors: [],
                });
                this.altar.push({
                    shape: new Phaser.Geom.Polygon([211, 355, 327, 261, 355, 367]),
                    image: this.add.polygon(70,58, [211, 355, 327, 261, 355, 367], ALT_CL_NTR).setAlpha(0),
                    primaryNeighbors: [0, 5],
                    secondaryNeighbors: [1, 6],
                });
                this.altar.push({
                    shape: new Phaser.Geom.Polygon([392, 209, 491, 128, 454, 263]),
                    image: this.add.polygon(50,70, [392, 209, 491, 128, 454, 263], ALT_CL_NTR).setAlpha(0),
                    primaryNeighbors: [2, 9],
                    secondaryNeighbors: [1, 8],
                });
                this.altar.push({
                    shape: new Phaser.Geom.Polygon([211, 355, 355, 367, 391, 484]),
                    image: this.add.polygon(90,70, [211, 355, 355, 367, 391, 484], ALT_CL_NTR).setAlpha(0),
                    primaryNeighbors: [3, 6],
                    secondaryNeighbors: [],
                });
                this.altar.push({
                    shape: new Phaser.Geom.Polygon([391, 484, 355, 367, 424, 371]),
                    image: this.add.polygon(30,55, [391, 484, 355, 367, 424, 371], ALT_CL_NTR).setAlpha(0),
                    primaryNeighbors: [5, 7],
                    secondaryNeighbors: [3, 8],
                });
                this.altar.push({
                    shape: new Phaser.Geom.Polygon([391, 484, 424, 371, 572, 370]),
                    image: this.add.polygon(90,55, [391, 484, 424, 371, 572, 370], ALT_CL_NTR).setAlpha(0),
                    primaryNeighbors: [6, 8],
                    secondaryNeighbors: [],
                });
                this.altar.push({
                    shape: new Phaser.Geom.Polygon([424, 371, 572, 370, 454, 263]),
                    image: this.add.polygon(70,50, [424, 371, 572, 370, 454, 263], ALT_CL_NTR).setAlpha(0),
                    primaryNeighbors: [7, 9],
                    secondaryNeighbors: [4, 6],
                });
                this.altar.push({
                    shape: new Phaser.Geom.Polygon([ 572, 370, 454, 263, 491, 128]),
                    image: this.add.polygon(60,120, [572, 370, 454, 263, 491, 128], ALT_CL_NTR).setAlpha(0),
                    primaryNeighbors: [4, 8],
                    secondaryNeighbors: [],
                });
            },

            createCrowd: function() {
                var count = this.level < 15 ? elementCounts[this.level-1] : 10;
                // create the crowd
                for (var i=0; i<count; i++) {
                    var x = Math.floor(i/ROW_COUNT) == 0 ? FIRST_COL_X : SECND_COL_X;
                    var y = ROW_OFFSET + (i%ROW_COUNT) * OBJ_HEIGHT + OBJ_HEIGHT/2;
                    this.crowd.push({
                        image: undefined,
                        sacredness: Phaser.Math.RND.between(0,5),
                        initialPosition: { x: x, y: y },
                        currentPosition: { x: x, y: y },
                        currentAltarSlot: undefined,
                        loves: [],
                        hates: [],
                    });
                }
                // shuffle the crowd
                for (var i=0; i<count; i++) {
                    var newLoc = Phaser.Math.RND.between(0, 10);
                    var x = Math.floor(newLoc/ROW_COUNT) == 0 ? FIRST_COL_X : SECND_COL_X;
                    var y = ROW_OFFSET + (newLoc%ROW_COUNT) * OBJ_HEIGHT + OBJ_HEIGHT/2;
                    for (var j=0; j<count; j++) {
                        if (this.crowd[j].initialPosition.x == x && this.crowd[j].initialPosition.y == y) {
                            var nx = this.crowd[i].initialPosition.x;
                            var ny = this.crowd[i].initialPosition.y;
                            this.crowd[j].initialPosition = { x: nx, y: ny};
                            this.crowd[j].currentPosition = { x: nx, y: ny};
                            //this.crowd[j].image.setPosition(nx, ny);
                            break;
                        }
                    }
                    this.crowd[i].initialPosition = { x: x, y: y };
                    this.crowd[i].currentPosition = { x: x, y: y };
                    //this.crowd[i].image.setPosition(x, y);
                }
            },

            createPuzzle: function() {
                for (var i=0; this.crowd[i]; i++) {
                    var name = "";
                    var randomType = -1;
                    var randomInnerType = -1;
                    do {
                        randomType = Phaser.Math.RND.between(0,3);
                        randomInnerType = Phaser.Math.RND.between(0,6);
                        name = crowdData[randomType].species[randomInnerType];
                        for (var j=0; j<i; j++) {
                            if (this.crowd[j].name == name) {
                                name = "";
                                break;
                            }
                        }
                    } while (name == "");
                    this.crowd[i].name = name;
                    this.crowd[i].image = this.add.image(this.crowd[i].initialPosition.x, this.crowd[i].initialPosition.y, this.crowd[i].name).setAlpha(0);
                    this.crowd[i].sacredness = crowdData[randomType].averageSacredness[randomInnerType];
                    this.crowd[i].currentSacredness = 0;
                }
                this.limit = 0;
                for (var i=0; this.crowd[i]; i++) {
                    var altarPart = null;
                    do {
                        altarPart = this.altar[Phaser.Math.RND.between(0, this.altar.length-1)];
                        if (altarPart.occupee) {
                            altarPart = null;
                            continue;
                        }
                        var flag = false;
                        for (var j=0; altarPart.primaryNeighbors[j] && !flag; j++)
                            if (this.altar[altarPart.primaryNeighbors[j]].occupee)
                                flag = true;
                        for (var j=0; altarPart.secondaryNeighbors[j] && !flag; j++)
                            if (this.altar[altarPart.secondaryNeighbors[j]].occupee)
                                flag = true;
                        if (flag && Phaser.Math.RND.between(0,5) == 0)
                            altarPart = null;
                        else if (!flag && Phaser.Math.RND.between(0,5) > 0)
                            altarPart = null;
                    } while (altarPart == null);
                    altarPart.occupee = this.crowd[i];
                    this.crowd[i].currentAltarSlot = altarPart;
                }
                var constraints = this.level < 15 ? relationCounts[this.level-1] : 8 + this.level - 15;
                if (constraints > 20)
                    constraints = 20;
                var trial = 0;
                while (constraints > 0 && trial++ < 99) {
                    var altarPart1 = -1;
                    var altarPart2 = -1;
                    do {
                        altarPart1 = Phaser.Math.RND.between(0, this.altar.length-1);
                        if (!this.altar[altarPart1].occupee)
                            altarPart1 = -1;
                    } while (altarPart1 == -1);
                    do {
                        altarPart2 = Phaser.Math.RND.between(0, this.altar.length-1);
                        if (!this.altar[altarPart2].occupee || altarPart1 == altarPart2)
                            altarPart2 = -1;
                    } while (altarPart2 == -1);
                    var primaryNeighbors = this.altar[altarPart1].primaryNeighbors.includes(altarPart2);
                    var secondaryNeighbors = this.altar[altarPart1].secondaryNeighbors.includes(altarPart2);
                    var isMutual = Phaser.Math.RND.sign();
                    var occupee1 = this.altar[altarPart1].occupee;
                    var occupee2 = this.altar[altarPart2].occupee;
                    if (!occupee1.hates.includes(occupee2) && !occupee1.loves.includes(occupee2)) {
                        if (primaryNeighbors) {
                            var prob = Phaser.Math.RND.between(0,99);
                            if (prob < 80) {
                                occupee1.loves.push(occupee2);
                                if (isMutual)
                                    occupee2.loves.push(occupee1);
                            } else if (prob < 90 && isMutual) {
                                occupee1.loves.push(occupee2);
                                occupee2.hates.push(occupee1);
                            } else {
                                occupee1.hates.push(occupee2);
                                if (isMutual)
                                    occupee2.hates.push(occupee1);
                            }
                        } else if (secondaryNeighbors) {
                            var prob = Phaser.Math.RND.between(0,99);
                            if (prob < 33) {
                                occupee1.loves.push(occupee2);
                                if (isMutual)
                                    occupee2.loves.push(occupee1);
                            } else if (prob < 66 && isMutual) {
                                occupee1.loves.push(occupee2);
                                occupee2.hates.push(occupee1);
                            } else {
                                occupee1.hates.push(occupee2);
                                if (isMutual)
                                    occupee2.hates.push(occupee1);
                            }
                        } else {
                            var prob = Phaser.Math.RND.between(0,99);
                            if (prob < 80) {
                                occupee1.hates.push(occupee2);
                                if (isMutual)
                                    occupee2.hates.push(occupee1);
                            } else if (prob < 90 && isMutual) {
                                occupee1.loves.push(occupee2);
                                occupee2.hates.push(occupee1);
                            } else {
                                occupee1.loves.push(occupee2);
                                if (isMutual)
                                    occupee2.loves.push(occupee1);
                            }
                        }
                        trial = 0;
                        constraints -= 1;
                    }
                }
                this.updateScore(true);
                this.limit = this.score;
                this.timer = this.level < 15 ? levelDurations[this.level-1] : 50;
                for (var i=0; this.crowd[i]; i++) {
                    this.crowd[i].currentSacredness = 0;
                    if (this.crowd[i].currentAltarSlot) {
                        this.crowd[i].currentAltarSlot.occupee = undefined;
                        this.crowd[i].currentAltarSlot = undefined;
                    }
                }
                this.levelHUD.setText("lvl-" + this.level);
                this.timerHUD.setText(this.timer + " secs\nleft");
                this.updateScore(true);
                for (var i=0; this.crowd[i]; i++) {
                    this.tweens.add({
                        targets: this.crowd[i].image,
                        alpha: 1,
                        delay: i * RISE_DURATION,
                        duration: RISE_DURATION,
                        ease: 'Back.easeInOut',
                    });
                }
                this.time.delayedCall(1000, updateTimer, [this]);
            },

            selectCrowdMember: function(x, y) {
                for (var i=0; this.crowd[i]; i++) {
                    if (this.crowd[i].image.getBounds().contains(x, y)) {
                        this.selected = this.crowd[i];
                        //-- selected crowd member's altar position is now unoccupied --//
                        if (this.selected.currentAltarSlot)
                            this.selected.currentAltarSlot.occupee = undefined;
                        this.selected.currentAltarSlot = undefined;
                        //-- selected crowd member's altar position is now unoccupied --//
                        
                        //-- reset sacredness after every select --//
                        this.infoCard.setText("");
                        return;
                    }
                }
            },

            moveSelectedCrowdMember: function(x, y) {
                this.selected.image.x = this.selected.currentPosition.x + x;
                this.selected.image.y = this.selected.currentPosition.y + y;
            },

            checkAltar: function(x, y) {
                var firstTimeFlag = false;
                for (var i=0; this.altar[i]; i++) {
                    // if the pointer points at an altar slot
                    if (this.altar[i].shape.contains(x, y)) {
                        // if that altar slot is already occupied
                        if (this.altar[i].occupee) {

                        } 
                        // if that altar slot is unoccupied and pointed for the first time
                        else if (this.hovered != this.altar[i]) {
                            this.altar[i].image.setFillStyle(ALT_CL_NTR);
                            this.tweens.add({
                                targets: this.altar[i].image,
                                alpha: HIGHLIGHTED_ALPHA,
                                duration: HIGHLIGHT_DURATION,
                            });
                            firstTimeFlag = true;
                        }
                        // if any other altar slot is highlighted although it is not pointed
                        if (this.hovered && this.hovered != this.altar[i]) {
                            // canceling tile itself
                            this.tweens.add({
                                targets: this.hovered.image,
                                alpha: 0,
                                duration: HIGHLIGHT_DURATION,
                            });
                            // canceling primary neighbors
                            for (var j=0; j<this.hovered.primaryNeighbors.length; j++) {
                                var neighbor = this.altar[this.hovered.primaryNeighbors[j]].occupee;
                                if (neighbor) {
                                     this.tweens.add({
                                        targets: this.altar[this.hovered.primaryNeighbors[j]].image,
                                        alpha: 0,
                                        duration: HIGHLIGHT_DURATION,
                                    });
                                }
                            }
                            // canceling secondary neighbors
                            for (var j=0; j<this.hovered.secondaryNeighbors.length; j++) {
                                var neighbor = this.altar[this.hovered.secondaryNeighbors[j]].occupee;
                                if (neighbor) {
                                     this.tweens.add({
                                        targets: this.altar[this.hovered.secondaryNeighbors[j]].image,
                                        alpha: 0,
                                        duration: HIGHLIGHT_DURATION,
                                    });
                                }
                            }
                        }
                        this.hovered = this.altar[i];
                        if (firstTimeFlag) {
                            // primary neighbors
                            for (var j=0; j<this.altar[i].primaryNeighbors.length; j++) {
                                var neighbor = this.altar[this.altar[i].primaryNeighbors[j]];
                                if (neighbor.occupee && neighbor.occupee.loves.includes(this.selected)) {
                                    neighbor.image.setFillStyle(ALT_CL_IN1);
                                    this.tweens.add({
                                        targets: neighbor.image,
                                        alpha: HIGHLIGHTED_ALPHA,
                                        duration: HIGHLIGHT_DURATION,
                                    });
                                } else if (neighbor.occupee && neighbor.occupee.hates.includes(this.selected)) {
                                    neighbor.image.setFillStyle(ALT_CL_DC1);
                                    this.tweens.add({
                                        targets: neighbor.image,
                                        alpha: HIGHLIGHTED_ALPHA,
                                        duration: HIGHLIGHT_DURATION,
                                    });
                                }
                            }
                            // secondary neighbors
                            for (var j=0; j<this.altar[i].secondaryNeighbors.length; j++) {
                                var neighbor = this.altar[this.altar[i].secondaryNeighbors[j]];
                                if (neighbor.occupee && neighbor.occupee.loves.includes(this.selected)) {
                                    neighbor.image.setFillStyle(ALT_CL_IN2);
                                    this.tweens.add({
                                        targets: neighbor.image,
                                        alpha: HIGHLIGHTED_ALPHA,
                                        duration: HIGHLIGHT_DURATION,
                                    });
                                } else if (neighbor.occupee && neighbor.occupee.hates.includes(this.selected)) {
                                    neighbor.image.setFillStyle(ALT_CL_DC2);
                                    this.tweens.add({
                                        targets: neighbor.image,
                                        alpha: HIGHLIGHTED_ALPHA,
                                        duration: HIGHLIGHT_DURATION,
                                    });
                                }
                            }
                        }
                        return;
                    }
                }
                // if this function reaches here then the selected crowd member isn't in the altar
                if (this.hovered) {
                    this.tweens.add({
                        targets: this.hovered.image,
                        alpha: 0,
                        duration: HIGHLIGHT_DURATION,
                    });
                    // canceling primary neighbors
                    for (var j=0; j<this.hovered.primaryNeighbors.length; j++) {
                        var neighbor = this.altar[this.hovered.primaryNeighbors[j]];
                        if (neighbor) {
                            this.tweens.add({
                                targets: this.altar[this.hovered.primaryNeighbors[j]].image,
                                alpha: 0,
                                duration: HIGHLIGHT_DURATION,
                            });
                        }
                    }
                    // canceling secondary neighbors
                    for (var j=0; j<this.hovered.secondaryNeighbors.length; j++) {
                        var neighbor = this.altar[this.hovered.primaryNeighbors[j]];
                        if (neighbor) {
                            this.tweens.add({
                                targets: this.altar[this.hovered.secondaryNeighbors[j]].image,
                                alpha: 0,
                                duration: HIGHLIGHT_DURATION,
                            });
                        }
                    }
                }
                this.hovered = undefined;
            },

            checkCrowd: function(x, y) {
                // find the pointed crowd member in the inventory
                var object = undefined;
                for (var i=0; this.crowd[i]; i++) {
                    if (this.crowd[i].image.getBounds().contains(x, y) && !this.crowd[i].currentAltarSlot) {
                        object = this.crowd[i];
                        break;
                    }
                }
                // if there isn't any pointed crowd member then hide the info box
                if (!object)
                    this.infoCard.setText("");
                // if the pointed crowd member is not same with the previous one
                else if (object != this.informed) {
                    var str = object.name + "\nsp: " + object.sacredness;
                    for (var i=0; i<object.loves.length; i++)
                        str += "\nloves " + object.loves[i].name;
                    for (var i=0; i<object.hates.length; i++)
                        str += "\nhates " + object.hates[i].name;
                    this.infoCard.setText(str).setActive(true);
                    // for the alignments of the left inventory
                    if (object.initialPosition.x == FIRST_COL_X) {
                        this.infoCard.style.align = "left";
                        this.infoCard.setOrigin(0, 0.5);
                        this.infoCard.setPosition(object.initialPosition.x + OBJ_HEIGHT/2, object.initialPosition.y);
                    } 
                    // for the alignments of the right inventory
                    else {
                        this.infoCard.style.align = "right";
                        this.infoCard.setOrigin(1, 0.5);
                        this.infoCard.setPosition(object.initialPosition.x - OBJ_HEIGHT/2, object.initialPosition.y);
                    }
                }
                this.informed = object;
            },

            reset: function() {
                this.selected.currentSacredness = 0;
                // when reset, the selected crowd member goes to initial position
                this.selected.image.x = this.selected.initialPosition.x;
                this.selected.image.y = this.selected.initialPosition.y;
                this.selected.currentPosition.x = this.selected.initialPosition.x;
                this.selected.currentPosition.y = this.selected.initialPosition.y;
                if (this.selected.currentAltarSlot) {
                    this.selected.currentAltarSlot.occupee = undefined;
                }
                this.selected.currentAltarSlot = undefined;
                this.selected = null;
                this.hovered = null;

                this.updateScore(false);

                // TODO: ?
                this.infoCard.setText("");
                this.informed = undefined;

                this.resetfx.play();
            },

            process: function() {
                // reset the hovered altar part
                this.tweens.add({
                    targets: this.hovered.image,
                    alpha: 0,
                    duration: 330,
                });

                // canceling primary neighbors
                for (var j=0; j<this.hovered.primaryNeighbors.length; j++) {
                    var neighbor = this.altar[this.hovered.primaryNeighbors[j]].occupee;
                    if (neighbor) {
                        this.tweens.add({
                            targets: this.altar[this.hovered.primaryNeighbors[j]].image,
                            alpha: 0,
                            duration: HIGHLIGHT_DURATION,
                        });
                    }
                }
                // canceling secondary neighbors
                for (var j=0; j<this.hovered.secondaryNeighbors.length; j++) {
                    var neighbor = this.altar[this.hovered.primaryNeighbors[j]].occupee;
                    if (neighbor) {
                        this.tweens.add({
                            targets: this.altar[this.hovered.secondaryNeighbors[j]].image,
                            alpha: 0,
                            duration: HIGHLIGHT_DURATION,
                        });
                    }
                }

                // if the pointed altar part is already occupied
                if (this.hovered.occupee) {
                    this.reset();
                    return;
                }

                // find the centrum of the pointed altar part
                // feet of the character will be at this point
                var centerX = 0, centerY = 0;
                for (var i=0; this.hovered.shape.points[i]; i++) {
                    centerX += this.hovered.shape.points[i].x;
                    centerY += this.hovered.shape.points[i].y;
                }
                centerX /= this.hovered.shape.points.length;
                centerY /= this.hovered.shape.points.length;

                this.selected.image.x = centerX;
                this.selected.image.y = centerY;
                this.selected.currentPosition.x = centerX;
                this.selected.currentPosition.y = centerY;

                // if there is an occupied altar slot then release it
                if (this.selected.currentAltarSlot) {
                    this.selected.currentAltarSlot.occupee = undefined;
                }
                // assign altar slot and crowd member to each other
                this.selected.currentAltarSlot = this.hovered;
                this.hovered.occupee = this.selected;

                this.selected = null;
                this.hovered = null;

                this.updateScore(false);

                // TODO: ?
                this.infoCard.setText("");
                this.informed = undefined;

                this.placefx.play();
            },

            updateScore: function(test) {
                this.score = 0;
                for (var i=0; this.altar[i]; i++) {
                    if (!this.altar[i].occupee)
                        continue;
                    var score = this.altar[i].occupee.sacredness;
                    for (var j=0; j<this.altar[i].primaryNeighbors.length; j++) {
                        var neighbor = this.altar[this.altar[i].primaryNeighbors[j]].occupee;
                        if (neighbor) {
                            if (this.altar[i].occupee.loves.includes(neighbor))
                                score += 2;
                            if (this.altar[i].occupee.hates.includes(neighbor))
                                score -= 2;
                        }
                    }
                    for (var j=0; j<this.altar[i].secondaryNeighbors.length; j++) {
                        var neighbor = this.altar[this.altar[i].secondaryNeighbors[j]].occupee;
                        if (neighbor) {
                            if (this.altar[i].occupee.loves.includes(neighbor))
                                score += 1;
                            if (this.altar[i].occupee.hates.includes(neighbor))
                                score -= 1;
                        }
                    }
                    if (score != this.altar[i].occupee.currentSacredness && !test)
                        this.createNumberEffect(this.altar[i].occupee, score - this.altar[i].occupee.currentSacredness);
                    this.score += score;
                    this.altar[i].occupee.currentSacredness = score;
                }
                this.scoreHUD.setText("sacredness\n" + this.score + "/" + this.limit);
                if (this.score >= this.limit && !test)
                    this.levelCleared();
            },

            levelCleared: function() {
                this.timer = -2;
                for (var i=0; this.crowd[i]; i++) {
                    this.tweens.add({
                        targets: this.crowd[i].image,
                        y: "0",
                        scaleY: "1.4",
                        alpha: 0,
                        duration: END_LEVEL_DURATION,
                        ease: 'Circular.easeIn',
                    });
                }
                this.time.delayedCall(END_LEVEL_DURATION, globalLevelClearer, [this]);
            },

            destroyCrowd: function() {
                for (var i=0; this.altar[i]; i++)
                    this.altar[i].occupee = undefined;
                for (var i=0; this.crowd[i]; i++)
                    this.crowd[i].image.destroy();
                this.crowd = [];
            },

            createNumberEffect: function(occupee, deltaScore) {
                var style = deltaScore > 0 ? positiveFeedback : negativeFeedback;
                var str = deltaScore + "";
                if (deltaScore > 0)
                    str = "+" + str;
                var textElement = this.add.text(occupee.currentPosition.x, occupee.currentPosition.y - OBJ_HEIGHT, str, style);
                this.tweens.add({
                    targets: textElement,
                    y: "-=200",
                    alpha: 0,
                    duration: FEEDBACK_DURATION,
                    onComplete: globalDestroyer,
                    onCompleteParams: [textElement],
                    ease: 'Back.easeInOut',
                });
            },

            gameOver: function() {
                this.selected = undefined;
                this.hovered = undefined;
                this.lock = true;
                for(var i=0; this.crowd[i]; i++) {
                    this.tweens.add({
                        targets: this.crowd[i].image,
                        alpha: 0,
                        duration: ANIMATION_DURATION,
                        ease: 'Back.easeInOut',
                        onComplete: globalDestroyer,
                        onCompleteParams: [this.crowd[i].image],
                    });
                }
                this.tweens.add({
                    targets: this.altarStar,
                    alpha: 0,
                    duration: ANIMATION_DURATION,
                    ease: 'Back.easeInOut',
                    onComplete: globalGameOverSceneStarter,
                    onCompleteParams: [this],
                });
                this.theme.volume = MENU_VOLUME;
            },

            gameOverScene: function() {
                this.lock = false;
                this.gameOverHUD = this.add.text(345, 175, "game over", negativeFeedback).setOrigin(0.5, 0.5);
                this.lastScoreHUD = this.add.text(345, 225, "your score is " + this.level, positiveFeedback).setOrigin(0.5, 0.5);
                this.menuMug = this.add.image(400, 300, "mug");
                this.level = 0;
            },
        });

        var config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            scene: SMBM,
        };
        var game = new Phaser.Game(config);

        function globalGameStarter(tween, targets, that) {
            that.menuTitle.destroy();
            that.createGame();
        }

        function globalLevelClearer(that) {
            that.destroyCrowd();
            that.level++;
            that.createCrowd();
            that.createPuzzle();
        }

        function globalDestroyer(tween, targets, element) {
            element.destroy();
        }

        function globalLevelStarter(that) {
            that.createCrowd();
            that.createPuzzle();
        }

        function updateTimer(that) {
            if (that.timer > 0) {
                that.tick.play();
                that.timer--;
                that.timerHUD.setText(that.timer + " secs\n left");
                that.time.delayedCall(1000, updateTimer, [that]);
            } else if (that.timer == 0){
                that.gameOver();
            }
        }

        function globalGameOverSceneStarter(tween, targets, that) {
            for (var i=0; that.altar[i]; i++)
                that.altar[i].image.destroy();
            that.altar = [];
            that.crowd = [];
            that.scoreHUD.setText("");
            that.timerHUD.setText("");
            that.levelHUD.setText("");
            that.gameOverScene();
        }

    </script>
</body>
</html>